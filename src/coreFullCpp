#include "iostream"
#include "Eigen/Dense"
#include "Eigen/SVD"
 
using namespace Eigen;
using namespace std;

class oneComponent {
  public:
    VectorXd t;
    VectorXd U0;
    VectorXd V0;
    VectorXd V_svd;
};

class multiComponent {
public:
    MatrixXd U_out;
    MatrixXd V0;
};

oneComponent do_one_componentCpp(const MatrixXd x0,const MatrixXd y0,
                         const MatrixXd COV,
                         const int n,const int p,const int q,
                         double lam,double errorMin=1e-9){
  VectorXd max_cov_y = VectorXd::Zero(q);
  VectorXd max_cov_x = VectorXd::Zero(p);
  VectorXi id_y_high = VectorXi::Zero(q);
  int countNoNullY=0;
  VectorXi id_x_high = VectorXi::Zero(p);
  int countNoNullX=0;
  // Get max values per column and per row
  for (int i = 0u; i < q; ++i) {
    max_cov_y(i) = COV.block(i,0,1,p).array().abs().maxCoeff();
    if (max_cov_y(i)>lam){
      id_y_high(i) = 1;
      countNoNullY += 1;
    }
  }
  for (int j = 0u; j < p; ++j) {
    max_cov_x(j) = COV.block(0,j,q,1).array().abs().maxCoeff();
    if (max_cov_x(j)>lam){
      id_x_high(j) = 1;
      countNoNullX += 1;
    }
  }
  // Get reduced covariance matrix
  MatrixXd COV_high = MatrixXd::Zero(countNoNullY,countNoNullX);
  VectorXd U0 = VectorXd::Zero(p);
  VectorXd V0 = VectorXd::Zero(q);
  VectorXd V_svd = VectorXd::Zero(q);
  VectorXd t = VectorXd::Zero(n);
  int countY = 0u;
  int countX = 0u;
  if (countNoNullY>0){
    for (int i = 0u; i < q; ++i) {
      countX = 0u;
      if (id_y_high(i)==1){
        countX = 0u;
        for (int j = 0u; j < p; ++j) {
          if (id_x_high(j)==1){
            double coefIJ = COV(i,j);
            double value = abs(coefIJ)-lam;
            if (value>0) {
              if (coefIJ>0){
                COV_high(countY,countX) = value;
              } else {
                COV_high(countY,countX) = value*(-1.0);
              }
            }
            else {
              COV_high(countY,countX) = 0;
            }
            countX += 1;
          }
        }
        countY += 1;
      }
    }
    double error = 2.0;
    VectorXd u0In;
    u0In.setRandom(countNoNullX);
    VectorXd v0In(countNoNullY);
    u0In = u0In/sqrt(u0In.squaredNorm());
    VectorXd u0In2(countNoNullX);
    while(error>errorMin){
      v0In = COV_high*u0In;
      u0In2 = COV_high.transpose()*v0In;
      u0In2 /= sqrt(u0In2.squaredNorm());
      error = (u0In2-u0In).squaredNorm();
      u0In = u0In2;
    }
    v0In  /= sqrt(v0In.squaredNorm());
    countY = 0u;
    for (int i = 0u; i < q; ++i) {
      if (id_y_high(i)==1){
        V0(i) = v0In(countY);
        countY += 1;
      }
    }
    countX = 0u;
    for (int j = 0u; j < p; ++j) {
      if (id_x_high(j)==1){
        U0(j) = u0In(countX);
        countX += 1;
      }
    }
    // Build score
    t = x0*U0;
    // Build y0 masked
    for (int i = 0u; i < q; ++i) {
      if (id_y_high(i)==1){
        V_svd(i) = (y0.block(0,i,n,1).transpose()*t).sum();
      }
    }
    V_svd /= sqrt(V_svd.squaredNorm());
  }
  // Generate output
  oneComponent out;
  out.t = t;
  out.U0 = U0;
  out.V_svd = V_svd;
  out.V0 = V0;
  return(out);
}


multiComponent modelddsPLSCpp(MatrixXd U_out,MatrixXd V0,const MatrixXd x,
  const MatrixXd y,const int n,const int p,const int q,double lam=0.0,int R=1,
  double errorMin=1e-9){
  double RSS0=0.0;
  double normU02;
  double RSSr;
  double maxCOV=0.0;
  MatrixXd muX = MatrixXd::Zero(n,p);
  MatrixXd sdXInvMat = MatrixXd::Zero(p,q);
  MatrixXd muY = MatrixXd::Zero(n,q);
  MatrixXd sdYMat = MatrixXd::Zero(p,q);
  MatrixXd sdYXInvMat = MatrixXd::Zero(p,q);
  MatrixXd y_plus_un = MatrixXd::Zero(n,q);
  MatrixXd x_plus_un = MatrixXd::Zero(n,p);
  MatrixXd U_star = MatrixXd::Zero(p,R);
  MatrixXd V_out = MatrixXd::Zero(q,R);
  MatrixXd bXr = MatrixXd::Zero(R,p);
  MatrixXd bYr = MatrixXd::Zero(R,q);
  MatrixXd y_est = MatrixXd::Zero(n,q);
  MatrixXd B_r_0 = MatrixXd::Zero(p,q);
  MatrixXd y0 = y;
  MatrixXd x0 = x;
  MatrixXd COV = MatrixXd::Zero(q,p);
  VectorXd vectHere = VectorXd::Zero(n);
  VectorXd var_expl = VectorXd::Zero(R);
  VectorXd t_r = VectorXd::Zero(n);
  VectorXd U0 = VectorXd::Zero(p);
  VectorXd V_svd = VectorXd::Zero(q);
  VectorXd V0_r = VectorXd::Zero(q);
  VectorXd bt = VectorXd::Zero(p);
  VectorXd deltaU = VectorXd::Zero(p);
  // Compute initial residual sum of squares
  RSS0 = y0.squaredNorm();
cout << RSS0 << endl;
  // Begin to build subspaces
  for (int r = 0u; r < R; ++r) {
    cout << r << endl;
    // Build empirical covariance matrix
    COV = y0.transpose()*x0/double(n-1.0);
    maxCOV = COV.array().abs().maxCoeff();
    if(maxCOV>lam){
      oneComponent c_h = do_one_componentCpp(x0,y0,COV,n,p,q,lam,errorMin);
      t_r = c_h.t;
      U0 = c_h.U0;
      U_out.block(0,r,p,1) = U0;
      V_svd = c_h.V_svd;
      V0_r = c_h.V0;
      V0.block(0,r,q,1) = V0_r;
      // Build regression matrices
      normU02 = U0.squaredNorm();
      if(normU02>errorMin){
        bt = x0.transpose()*t_r/normU02;
        x_plus_un = t_r*bt.transpose();
        U_star.block(0,r,p,1) = U0;
        V_out.block(0,r,q,1) = V_svd;
        B_r_0 = U0*V_svd.transpose();
        y_plus_un = t_r*V_svd.transpose();
        y_est += y_plus_un;
        bXr.block(r,0,1,p) = bt.transpose();
        if(r>0){
          for (int s_r = r-1; s_r > 0; --s_r){
            deltaU = U_star.block(0,s_r,p,1)*(bXr.block(s_r,0,1,p)*U_star.block(0,s_r,p,1)).sum();
            U_star.block(0,r,p,1) = U_star.block(0,r,p,1) - deltaU;
          }
        }
        // Computation of explained variance
        RSSr = (y-y_plus_un).squaredNorm();
        var_expl(r) = 1.0-RSSr/RSS0;
        y0 -= y_plus_un;
        x0 -= x_plus_un;
      }
    }
  }
  multiComponent out;
  out.U_out = U_out;
  out.V0 = V0;
  return out;
}
 
