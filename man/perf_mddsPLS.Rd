% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/perf_mddsPLS.R
\name{perf_mddsPLS}
\alias{perf_mddsPLS}
\title{Function to compute cross-validation performances.}
\usage{
perf_mddsPLS(
  Xs,
  Y,
  lambda_min = 0,
  lambda_max = NULL,
  n_lambda = 1,
  lambdas = NULL,
  R = 1,
  L0s = NULL,
  mu = NULL,
  deflat = FALSE,
  weight = FALSE,
  kfolds = "loo",
  mode = "reg",
  fold_fixed = NULL,
  NCORES = 1,
  NZV = 1e-09,
  plot_result = T,
  legend_label = T
)
}
\arguments{
\item{Xs}{A matrix, if there is only one block, or a list of matrices,
if there is more than one block, of \strong{n} rows each, the number of individuals.
 Some rows must be missing. The different matrices can have different numbers of columns.
  The length of Xs is denoted by \strong{K}.}

\item{Y}{A matrix of n rows of a vector of length n detailing the
response matrix. No missing values are allowed in that matrix.}

\item{lambda_min}{A real in \eqn{[0,1]}. The minimum value considered.
Default is \eqn{0}.}

\item{lambda_max}{A real in \eqn{[0,1]}. The maximum value considered.
Default is \eqn{NULL}, interpreted to the largest correlation between
\strong{X} and \strong{Y}.}

\item{n_lambda}{A strictly positive integer. Default to \eqn{1}.}

\item{lambdas}{A vector of reals in \eqn{[0,1]}. The values tested by the
perf process. Default is \eqn{NULL}, when that parameter is not taken into account.}

\item{R}{A strictly positive integer detailing the number of components to
build in the model.}

\item{L0s}{A vector of non null positive integers. The values tested by the
perf process. Default is \eqn{NULL} and is then not taken into account.}

\item{mu}{A real positive. The Ridge parameter changing the bias of the regression model. If is NULL, consider the classical ddsPLS. Default to NULL.}

\item{deflat}{Logical. If TRUE, the solution uses deflations to construct the weights.}

\item{weight}{Logical. If TRUE, the scores are divided by the number of selected variables of their corresponding block.}

\item{kfolds}{character or integer. If equals to "loo" then a \strong{leave-one-out}
cross-validation is started. No other character is understood. Any strictly
positive integer gives the number of folds to make in the \strong{cross-validation process}}

\item{mode}{A character chain. Possibilities are "\strong{(reg,lda,logit)}", which implies regression problem, linear discriminant analysis (through the paclkage \code{MASS}, function \code{lda}) and logistic regression (function \code{glm}). Default is \strong{reg}.}

\item{fold_fixed}{Vector of length \eqn{n}. Each element corresponds to the
fold of the corresponding fold. If NULL then that argument is not considerd.
Default to NULL.}

\item{NCORES}{Integer. The number of cores. Default is \eqn{1}.}

\item{NZV}{Float. The floatting value above which the weights are set to 0.}

\item{plot_result}{Logical. Wether or not to plot the result. Initialized to \strong{TRUE}. The \strong{reg_error} argument of the \strong{plot.perf_mddsPLS} function is left to its default value.}

\item{legend_label}{Logical. Wether or not to add the legend names to the plot. Initialized to \strong{TRUE}.}
}
\value{
The most practical output is
\describe{
\item{"Optim"}{
Two couples of candidates for optimal parameters, in a list, with names
\describe{
\item{"optim_para_all"}{The couple for which the mean of the cross-validated errors is extremum (minimum in the regression case and maximum in the classification case) along the \emph{q} response variables.}
\item{"optim_para_one"}{The couple for which the extremum (minimum in the regression case and maximum in the classification case) value over all the cross-validated errors is reached along the \emph{q} response variables.}
}
}
}
But other outputs allow deeper details on the computations
\describe{
\item{"RMSEP" in regression or "ERROR" in classification}{
The cross-validation mean errors where two first columns gather different values for the parameters.
}
\item{"SDEP"}{
The cross-validation standard deviation errors where two first columns gather different values for the parameters.
}
\item{"FREQ"}{
The number of times each response variables is selected in the cross-validation process where two first columns gather different values for the parameters.
}
\item{"Conv"}{
The number of iterations in the \emph{tribe stage} of the \emph{Koh-Lanta} algorithm (column 4), for each fold (column 2) where two first columns gather different values for the parameters.
}
\item{"time"}{
The computation time of the \emph{Koh-Lanta} algorithm (column 4), for each fold (column 2) where two first columns gather different values for the parameters.
}
\item{"fold"}{
The identification of each observation fold.
}
\item{"BackUp"}{
The source data used to estimate the previous statistics.
}
}
}
\description{
That function must be applied to the given dataset and
the cross-validation process is made on the given set
of parameters.
}
\examples{
# Classification example :
data("penicilliumYES")
X <- penicilliumYES$X
X <- scale(X[,which(apply(X,2,sd)>0)])
Y <- as.factor(unlist(lapply(c("Melanoconidiu","Polonicum","Venetum"),
function(tt){rep(tt,12)})))
#res_cv_class <- perf_mddsPLS(X,Y,L0s=1:5,R = 2,
#mode = "lda",NCORES = 1,fold_fixed = rep(1:12,3))

# Regression example :
data("liverToxicity")
X <- scale(liverToxicity$gene)
Y <- scale(liverToxicity$clinic)
#res_cv_reg <- perf_mddsPLS(Xs = X,Y = Y,L0s=c(1,5,10,25,50),R = 1,
# mode = "reg")
}
\seealso{
\code{\link{summary.perf_mddsPLS}}, \code{\link{plot.perf_mddsPLS}}, \code{\link{mddsPLS}}, \code{\link{predict.mddsPLS}},
}
